## 信息的表示和处理

### 2.3.4  无符号乘法

$$
x \ *^u_w \ y = (x \cdot y ) \ mod \ 2^w
$$

> 无符号数乘法实际是在正确结果（需要$2w$位）基础上的截断，剩余的二进制向量仍然看成是无符号数。

### 2.3.4 补码乘法

$$
x \ *^t_w \ y = U2T_w(\ (x \cdot y ) \ mod \ 2^w)
$$

> 补码乘法实际也是在正确结果（需要$2w$位）基础上的截断，剩余的二进制向量被当成有符号数。

下面的例子说明了无符号和补码乘法的区别

| 模式   | $x$     | $y$     | $x \cdot y$ | 结果    |
| ------ | ------- | ------- | ----------- | ------- |
| 无符号 | $[101]$ | $[011]$ | $[001111]$  | $[111]$ |
| 补码   | $[101]$ | $[011]$ | $[110111]$  | $[111]$ |

由上面的例子我们还可以看到，虽然无符号乘法和补码乘法非截断的结果不一样，但是截断之后结果的二进制表示是一样的，这个被称为**位级等价性**。

给定长度为$w$的维向量$\vec x$和$\vec y$，其代表的补码数为$x$和$y$，其代表的无符号数为$x'$和$y'$，则
$$
T2B_w(x \ *^t_w \ y) = U2B_w(x' *^u_w\  y')
$$
此性质被称为位级等价性。

下面我们来证明下此推论。

首先，根据补码和无符号数的关系，可以得出
$$
(x' \cdot y')\ mod\ 2^w = ((x_{w-1}2^w + x) \cdot (y_{w-1}2^w + y))\ mod \ 2^w \\
= (x \cdot y)\ mod\ 2^w
$$
带入补码乘法的定义，可以得到
$$
x \ *^t_w \ y = U2T_w(\ (x' \cdot y')\ mod\ 2^w) \\
T2B_w(x \ *^t_w \ y) = T2B_w(U2T_w(\ (x' \cdot y')\ mod\ 2^w)) = U2B_w((x' \cdot y')\ mod\ 2^w) = U2B_w((x' *^u_w y')
$$
既得证。

**练习 2.35** 请阅读下面的代码

```c
int tmult_ok(int x, int y) {
	int p = x * y;
	return ~x || p / x == y;
}
```

前面已经看到，不能使用减法判断加法是否溢出，此处使用除法判断乘法是否溢出是否正确。

答案是正确的。证明可分三步。

1. 当$x=0$时，乘法不会发生溢出，程序显然是正确的；
2. 当$x!=0$时，存在$r, q, m$，使得$x \cdot y = p + t2^w$，$p = q \cdot x + r, |r| < |x|$。由此可以得到$x \cdot y = q \cdot x + r + t2^w$。
3. 假如$q!=y$，则$r+t2^w！=0$，由于$|r| < |x| < 2^w$，该等式恒不能成立，因此$q=y$恒成立。

**XDR库中的安全漏洞**

```c
void copy_elements(void *ele_src[], int ele_cnt, size_t ele_size) {
    return results;
}
```

这段代码的功能是将`ele_src`中的`ele_cnt`个长度为